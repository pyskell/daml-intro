daml 1.2

module Main (
  module Main
  ) where
import DA.List
import Prelude hiding (Action)

template AuthorizationPlaceholder
  with
    provider : Party
    signers : [Party]
    minimum : Int
  where
    signatory signers
    observer provider
    ensure
      unique signers

    controller provider can
      nonconsuming Do_Action : Bool
        do
          -- Provider can put whatever side effects/business logic they want here
          return True

template PendingAuthorization
  with
    authorization : AuthorizationPlaceholder
    signedBy : [Party]
    rejectedBy : [Party]
  where
    signatory signedBy ++ rejectedBy
    observer authorization.signers
    ensure unique $ signedBy ++ rejectedBy

    let remaining = authorization.signers \\ (signedBy ++ rejectedBy)

    choice Authorization_Sign : ContractId PendingAuthorization with
        signer : Party

      controller signer
        do
          assert $ elem signer remaining
          create this with
            signedBy = signer :: signedBy
    
    choice Authorization_Reject : ContractId PendingAuthorization with
        signer : Party
      
      controller signer
        do
          assert $ elem signer remaining
          -- If a party rejects the contract they remove themselves from the signers
          let signers = delete signer authorization.signers
          let auth = authorization with signers

          create this with
            rejectedBy = signer :: rejectedBy
            authorization = auth
    
    choice Authorization_Complete : ContractId AuthorizationPlaceholder with
        signer : Party

      controller signer
        do
          assertMsg "Not enough approvals" (length signedBy >= authorization.minimum)
          create authorization

  -- Alice wants to modify the DNS records of a very critical 
  -- domain name controlled by her DNS Provider
  -- This change requires the approval of at least 3 of 4 participants
  -- within her organization.
  -- To do this she creates a series of contracts that will:
  -- Coordinate the signing of the contract (PendingAuthorization)
  -- Create the action she wants to perform (AuthorizationPlaceholder)
  -- Once completed the Provider can perform Do_Action on the AuthorizationPlaceholder to finish the authorization process. The successful exercise of this action signals to the provider that the rules of the pre-agreed AuthorizationPlaceholder were followed
test_auth = scenario do

  parties@[alice, bob, carol, dave] <- mapA getParty ["Alice", "Bob", "Carol", "Dave"]

  -- The provider has previously negotiated the AuthorizationPlaceholder
  -- with Alice's team and provides them with this placeholder when they
  -- want to make a DNS change.
  provider <- getParty "Provider"
  let auth = AuthorizationPlaceholder with signers = parties, minimum = 3, provider

  -- Alice cannot replace the provider with her own and pass off a fake AuthorizationPlaceholder
  fakeProvider <- getParty "FakeProvider"
  let badAuth = AuthorizationPlaceholder with signers = [alice], minimum = 1, provider = fakeProvider

  badAuth <- submit alice do
    create PendingAuthorization with
      authorization = badAuth
      signedBy = [alice]
      rejectedBy = []

  badCompletedAuth <- submit alice do
    exercise badAuth Authorization_Complete with signer = alice

  -- The provider cannot perform Do_Action on the bad contract as they are not aware of it
  submitMustFail provider do
    exercise badCompletedAuth Do_Action

  -- Alice cannot create a contract where some have already signed/rejected
  submitMustFail alice do
    create PendingAuthorization with
      authorization = auth
      signedBy = [alice, bob, carol]
      rejectedBy = [dave]

  -- Alice cannot both sign and reject a contract
  submitMustFail alice do
    create PendingAuthorization with
      authorization = auth
      signedBy = [alice]
      rejectedBy = [alice]

  pendingAuth <- submit alice do
    create PendingAuthorization with
      authorization = auth
      signedBy = [alice]
      rejectedBy = []
  
  pendingAuth <- submit bob do
    exercise pendingAuth Authorization_Sign with signer = bob
  
  -- Bob cannot sign for someone else
  submitMustFail bob do
    exercise pendingAuth Authorization_Sign with signer = carol
  
  -- Alice cannot complete a contract that does not >= minimum signatures
  submitMustFail alice do
    exercise pendingAuth Authorization_Complete with signer = alice

  -- Carol can reject the authorization
  pendingAuth <- submit carol do
    exercise pendingAuth Authorization_Reject with signer = carol

  -- But she cannot sign later
  submitMustFail carol do
    exercise pendingAuth Authorization_Sign with signer = carol
  
  pendingAuth <- submit dave do
    exercise pendingAuth Authorization_Sign with signer = dave

  -- With enough signers Dave (or anyone) can complete the authorization
  completedAuth <- submit dave do
    exercise pendingAuth Authorization_Complete with signer = dave

  -- With the authorization completed the Provider can perform the action
  -- They described in the AuthorizationPlaceholder

  action <- submit provider do
    exercise completedAuth Do_Action

  assert action