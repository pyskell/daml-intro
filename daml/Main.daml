-- TODO: Write tests that test all assertions in Authorization_Bulk
daml 1.2

module Main (
  module Main
  ) where
import DA.List

template PartyAuth
  with
    pendingAuth : ContractId PendingAuthorization
    provider : Party
    signer : Party
    decision : Bool
  where
    signatory signer
    observer provider

template AuthorizationPlaceholder
  with
    provider : Party
    signers : [Party]
    minimum : Int
  where
    signatory provider
    observer signers
    ensure
      unique $ provider :: signers

template PendingAuthorization
  with
    provider : Party
    authorization : AuthorizationPlaceholder
    signedBy : [Party]
    rejectedBy : [Party]
  where
    signatory authorization.provider
    observer authorization.signers
    ensure unique $ authorization.provider :: signedBy ++ rejectedBy

    let 
      remaining = authorization.signers \\ signedBy ++ rejectedBy
      getPartySigner x = x.signer

    choice Authorization_Bulk : ContractId PendingAuthorization with
        signatures : [PartyAuth]
      controller provider
        do
          let isRemaining s = (getPartySigner s) `elem` remaining
          -- Make sure the array of signatures can sign
          assertMsg "Invalid signature(s) provided." $ all isRemaining signatures
          -- Make sure this is the correct contract being signed for
          let correctContract x = x.pendingAuth == self
          assertMsg "PartyAuth does not match this contract" $ all correctContract signatures

          let getDecision x = x.decision
          let bulkSigned = map getPartySigner $ filter getDecision signatures
          let bulkRejected = map getPartySigner $ filter (not . getDecision) signatures

          -- This non-interactive version differs from the interactive version
          -- because it cannot control for changing approvals
          create this with
            signedBy = bulkSigned ++ signedBy
            rejectedBy = bulkRejected ++ rejectedBy

    choice Authorization_Complete : ContractId AuthorizationPlaceholder
      controller provider
        do
          assertMsg "Not enough approvals" (length signedBy >= authorization.minimum)
          -- assertMsg "Signature(s) are not members of the authorization" $ all (`elem` signedBy) authorization.signers
          create authorization

  -- Alice wants to modify the DNS records of a very critical 
  -- domain name controlled by her DNS Provider
  -- This change requires the approval of at least 3 of 4 participants within her organization (Alice, Bob, Carol, and Dave).
  -- To do this the Provider creates a PendingAuthorization which contains 
  -- the AuthorizationPlaceholder and waits for the signers to approve it
  -- If they do approve it the DNS Provider will

  -- The provider has previously negotiated the PendingAuthorization with Alices team
  -- and provides them with the same contract each time they want to make a DNS change
test_auth = scenario do

  parties@[alice, bob, carol, dave] <- mapA getParty ["Alice", "Bob", "Carol", "Dave"]
  provider <- getParty "Provider"

  let authorization = AuthorizationPlaceholder with signers = parties, minimum = 3, provider

  -- TODO: FIX
  -- Providers cannot create a contract where some have already signed/rejected
  -- badAuth <- submit provider do
  --   create PendingAuthorization with
  --     provider
  --     authorization
  --     signedBy = [alice, bob, carol]
  --     rejectedBy = [dave]

  -- submitMustFail provider do
  --   exercise badAuth Authorization_Complete

  -- Alice cannot both sign and reject a contract
  submitMustFail alice do
    create PendingAuthorization with
      provider
      authorization
      signedBy = [alice]
      rejectedBy = [alice]

  -- A provider cannot be a signer
  submitMustFail provider do
    create PendingAuthorization with
      provider
      authorization
      signedBy = [provider]
      rejectedBy = []

  -- Provider creates the contract
  pendingAuth <- submit provider do
    create PendingAuthorization with
      provider
      authorization
      signedBy = []
      rejectedBy = []

  aliceAuth <- submit alice do
    create PartyAuth with 
      pendingAuth
      provider
      signer = alice
      decision = True
  
  bobAuth <- submit bob do
    create PartyAuth with 
      pendingAuth
      provider
      signer = bob
      decision = True
  
  -- Bob cannot sign for someone else
  submitMustFail bob do
    create PartyAuth with 
      pendingAuth
      provider
      signer = carol
      decision = True
  
  -- Provider cannot complete a contract that does not >= minimum signatures
  submitMustFail provider do
    exercise pendingAuth Authorization_Complete

  -- Carol can reject the authorization
  carolAuth <- submit carol do
    create PartyAuth with 
      pendingAuth
      provider
      signer = carol
      decision = False
  
  daveAuth <- submit dave do
    create PartyAuth with 
      pendingAuth
      provider
      signer = dave
      decision = True

  -- Provider cannot submit PartyAuths from non-signatories
  emily <- getParty "Emily"
  emilyAuth <- submit emily do
    create PartyAuth with 
      pendingAuth
      provider
      signer = emily
      decision = True

  submitMustFail provider do
    signatures <- mapA fetch [aliceAuth, bobAuth, carolAuth, daveAuth, emilyAuth]
    exercise pendingAuth Authorization_Bulk with
      signatures

  -- With enough signers the Provider can complete the authorization
  submit provider do
    signatures <- mapA fetch [aliceAuth, bobAuth, carolAuth, daveAuth]
    pendingAuth <- exercise pendingAuth Authorization_Bulk with
      signatures
    exercise pendingAuth Authorization_Complete
    -- archive pendingAuth

-- fake_provider = scenario do
--   alice <- getParty "Alice"
--   fakeProvider <- getParty "FakeProvider"
--   provider <- getParty "Provider"

--   -- Alice cannot replace the provider with her own and pass off a fake AuthorizationPlaceholder to the service provider
--   let authorization = AuthorizationPlaceholder with signers = [alice], minimum = 1, provider = fakeProvider

--   -- FakeProviders cannot masquerade as the real entity
--   badAuth <- submit fakeProvider do
--     create PendingAuthorization with
--       provider = fakeProvider
--       authorization
--       signedBy = []
--       rejectedBy = []

--   badAuth <- submit alice do
--     exercise badAuth Authorization_Sign with signer = alice

--   -- Provider is unaware of the badAuth contract
--   submitMustFail provider do
--     exercise badAuth Authorization_Complete

--   submit fakeProvider do
--     badAuth <- exercise badAuth Authorization_Complete
--     archive badAuth