daml 1.2

module Main (
  module Main
  ) where
import DA.List
-- import DA.Next.Map as M

template AuthorizationPlaceholder
  with
    owners : [Party]
    minimum : Int
    -- approved : Bool
    -- approvers : M.Map Party Bool
  where
    -- let receivers = map fst $ toList $ M.filter (==False) approvers
    signatory owners
    ensure
      unique owners

    -- ensure not approved
  
    -- controller owner can
    --   Complete_Authorization
    --     : ContractId Authorization
    --     do
    --       let frequency = length $ toList $ M.filter (==True) approvers
    --       assertMsg "Not enough approvals" (frequency >= minimum)
    --       create this with
    --         approved = True

template PendingAuthorization
  with
    authorization : AuthorizationPlaceholder
    signedBy : [Party]
    rejectedBy : [Party]
  where
    signatory signedBy
    observer authorization.owners
    ensure unique signedBy ++ rejectedBy

    let remaining = authorization.owners \\ signedBy

    choice Authorization_Sign : ContractId PendingAuthorization with
        signer : Party

      controller signer
        do
          assert elem signer remaining
          create this with
            signedBy = signer :: signedBy
    
    choice Authorization_Reject : ContractId PendingAuthorization with
        signer : Party
      
      controller signer
        do
          assert elem signer remaining
          create this with
            rejectedBy = signer :: rejectedBy

    -- controller authorization.owner can
    --   UserAuthorization_Cancel
    --     : ContractId Authorization
    --     do
    --       create authorization with
    --         approvers = M.delete receiver authorization.approvers

test_auth = scenario do
  alice <- getParty "Alice"
  bob <- getParty "Bob"
  carol <- getParty "Carol"
  dave <- getParty "Dave"

  -- TODO: Make this fail
  -- Alice can create a contract where some have already approved
  -- You can see that known to and the approvers TextMap do not agree
  bad_contract <- submit alice do
    create Authorization with
      owner = alice
      approved = False
      minimum = 3
      approvers = M.fromList[(bob, False), (carol, True), (dave, False)]

  submit alice do archive bad_contract

  -- Alice can both be an owner and an approver
  auth <- submit alice do
    create Authorization with
      owner = alice
      approved = False
      minimum = 3
      approvers = M.fromList[(alice, False), (bob, False), (carol, False), (dave, False)]

  authProp <- submit alice do
    -- auth_bob <- fetch auth
    create AuthorizationProposal with
      sender = alice
      receivers = [alice, bob, carol, dave]
      authorization = auth

  -- Bob approves
  submit bob do
    exercise authProp UserAuthorization_Accept

  -- Alice doesn't have enough approvals
  submitMustFail alice do
    exercise auth Complete_Authorization

  submit carol do
    exercise authProp UserAuthorization_Accept

  submit alice do
    exercise auth Complete_Authorization

  -- -- Alice forwards Bob's completed proposal to Carol
  -- authPropCarol <- submit alice do
  --   auth_carol <- fetch authBobCid
  --   create AuthorizationProposal with
  --     sender = alice
  --     receiver = carol
  --     authorization = auth_carol

  -- authCarolCid <- submit carol do
  --   exercise authPropCarol UserAuthorization_Accept

  -- -- Alice forward's Carol's completed proposal to Dave
  -- authPropDave <- submit alice do
  --   auth_dave <- fetch authCarolCid
  --   create AuthorizationProposal with
  --     sender = alice
  --     receiver = dave
  --     authorization = auth_dave
  
  -- authDaveCid <- submit dave do
  --   exercise authPropDave UserAuthorization_Accept

  -- -- With enough Authorizations Alice can complete the multisig
  -- submit alice do
  --   exercise authDaveCid Complete_Authorization