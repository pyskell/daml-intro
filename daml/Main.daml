daml 1.2

module Main where
import DA.Next.Map as M

template Authorization
  with
    owner : Party
    approved : Bool
    approvers : M.Map Party Bool
    minimum : Int
  where
    signatory owner
    -- ensure not approved
    
    controller owner can
      Send_Authorization
        : ContractId Authorization
        do
          create this
    controller owner can
      nonconsuming Complete_Authorization
        : ContractId Authorization
        do
          let frequency = length $ toList $ M.filter (==True) approvers
          assertMsg "Not enough approvals" (frequency >= minimum)
          create this with
            approved = True

template AuthorizationProposal
  with
    sender : Party
    receiver : Party
    authorization : Authorization
  where
    signatory (signatory authorization)
    ensure sender == authorization.owner -- Sender must be owner

    controller receiver can
      UserAuthorization_Accept
        : ContractId Authorization
        do
          assertMsg "sender and receiver cannot be the same party" (sender /= receiver)
          create authorization with
            approvers = M.insert receiver True authorization.approvers
    
    controller receiver can
      UserAuthorization_Reject
        : ContractId Authorization
        do
          create authorization

    controller authorization.owner can
      UserAuthorization_Cancel
        : ContractId Authorization
        do
          create authorization with
            approvers = M.delete receiver authorization.approvers

test_auth = scenario do
  alice <- getParty "Alice"
  bob <- getParty "Bob"
  carol <- getParty "Carol"
  dave <- getParty "Dave"

  -- TODO: Make this fail
  -- Alice can create a contract where some have already approved
  -- You can see that known to and the approvers TextMap do not agree
  submit alice do
    create Authorization with
      owner = alice
      approved = False
      minimum = 2
      approvers = M.fromList[(bob, False), (carol, True), (dave, False)]

  -- Alice can both be an owner and an approver
  auth <- submit alice do
    create Authorization with
      owner = alice
      approved = False
      minimum = 2
      approvers = M.fromList[(alice, False), (bob, False), (carol, False), (dave, False)]

  authPropBob <- submit alice do
    auth_bob <- fetch auth
    create AuthorizationProposal with
      sender = alice
      receiver = bob
      authorization = auth_bob

  -- Bob approves
  authBobCid <- submit bob do
    exercise authPropBob UserAuthorization_Accept

  -- Alice doesn't have enough approvals
  submitMustFail alice do
    exercise authBobCid Complete_Authorization

  -- Bob sends auth request to carol
  authPropCarol <- submit alice do
    auth_carol <- fetch authBobCid
    create AuthorizationProposal with
      sender = alice
      receiver = carol
      authorization = auth_carol

  authCarolCid <- submit carol do
    exercise authPropCarol UserAuthorization_Accept

  submit alice do
    exercise authCarolCid Complete_Authorization 

  submit alice do
    create Authorization with
      owner = alice
      approved = False
      minimum = 2
      approvers = M.fromList[(bob, False), (carol, False), (dave, False)]