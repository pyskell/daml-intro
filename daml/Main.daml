daml 1.2

module Main (
  module Main
  ) where
import DA.List

template AuthorizationPlaceholder
  with
    signers : [Party]
    minimum : Int
  where
    signatory signers
    ensure
      unique signers

template PendingAuthorization
  with
    authorization : AuthorizationPlaceholder
    signedBy : [Party]
    rejectedBy : [Party]
  where
    signatory signedBy ++ rejectedBy
    observer authorization.signers
    ensure unique $ signedBy ++ rejectedBy

    let remaining = authorization.signers \\ (signedBy ++ rejectedBy)

    choice Authorization_Sign : ContractId PendingAuthorization with
        signer : Party

      controller signer
        do
          assert $ elem signer remaining
          create this with
            signedBy = signer :: signedBy
    
    choice Authorization_Reject : ContractId PendingAuthorization with
        signer : Party
      
      controller signer
        do
          assert $ elem signer remaining
          create this with
            rejectedBy = signer :: rejectedBy
    
    choice Authorization_Complete : ContractId AuthorizationPlaceholder with
        signer : Party

      controller signer
        do
          assertMsg "Not enough approvals" (length signedBy >= authorization.minimum)
          create authorization

    -- controller authorization.owner can
    --   UserAuthorization_Cancel
    --     : ContractId Authorization
    --     do
    --       create authorization with
    --         approvers = M.delete receiver authorization.approvers

test_auth = scenario do

  parties@[alice, bob, carol, dave] <- mapA getParty ["Alice", "Bob", "Carol", "Dave"]

  let auth = AuthorizationPlaceholder with signers = parties, minimum = 3

  -- Alice cannot create a contract where some have already approved
  submitMustFail alice do
    create PendingAuthorization with
      authorization = auth
      signedBy = [alice, bob, carol]
      rejectedBy = [dave]

  -- Alice cannot both sign and reject a contract
  submitMustFail alice do
    create PendingAuthorization with
      authorization = auth
      signedBy = [alice]
      rejectedBy = [alice]

  pendingAuth <- submit alice do
    create PendingAuthorization with
      authorization = auth
      signedBy = [alice]
      rejectedBy = []
  
  pendingAuth <- submit bob do
    exercise pendingAuth Authorization_Sign with signer = bob
  
  -- Bob cannot sign for someone else
  submitMustFail bob do
    exercise pendingAuth Authorization_Sign with signer = carol
  
  -- Alice cannot complete a contract that does not >= minimum signatures
  submitMustFail alice do
    exercise pendingAuth Authorization_Complete with signer = alice

  -- Carol can reject the authorization
  pendingAuth <- submit carol do
    exercise pendingAuth Authorization_Reject with signer = carol

  -- But she cannot sign later
  submitMustFail carol do
    exercise pendingAuth Authorization_Sign with signer = carol
  
  pendingAuth <- submit dave do
    exercise pendingAuth Authorization_Sign with signer = dave

  -- With enough signers Dave (or anyone) can complete the authorization
  submit dave do
    exercise pendingAuth Authorization_Complete with signer = dave